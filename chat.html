<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iMessage Style Dark Mode Chat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
    
    <style>
        /* iOS Dark Mode Colors (System Colors) */
        :root {
            --primary-bg: #000000; /* Ø®Ù„ÙÙŠØ© Ø³ÙˆØ¯Ø§Ø¡ Ù†Ù‚ÙŠØ© */
            --secondary-bg: #1C1C1E; /* Ù„ÙˆÙ† Ø§Ù„Ø®Ù„ÙÙŠØ© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© (Ù…Ø«Ù„ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª) */
            --tertiary-bg: #2C2C2E; /* Ø®Ù„ÙÙŠØ© Ø­Ù‚Ù„ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ */
            --text-color: #FFFFFF;
            --accent-color: #0A84FF; /* iOS Blue */
            --my-message-bg: #34C759; /* iOS System Green */
            --other-message-bg: #3A3A3C; /* Ù„ÙˆÙ† Ø±Ù…Ø§Ø¯ÙŠ Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø·Ø±Ù Ø§Ù„Ø¢Ø®Ø± */
            --info-color: #FF3B30; /* iOS System Red */
            --border-color: #38383a;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--primary-bg);
            color: var(--text-color);
        }
        
        /* Box-shadow for iOS-like elements */
        .ios-shadow {
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.4);
        }
        
        .chat-container {
            width: 100%;
            max-width: 30rem; 
            height: 100vh; 
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            background-color: var(--primary-bg); 
            overflow: hidden;
        }
        
        /* Header */
        .chat-header {
            background-color: var(--secondary-bg);
            border-bottom: 1px solid var(--border-color);
        }
        
        .messages-window {
            flex-grow: 1;
            overflow-y: auto;
            background-color: var(--primary-bg);
            padding: 0.5rem 1rem;
        }

        /* Message Bubbles - iMessage Style */
        .message-row {
            display: flex;
            margin-bottom: 0.5rem;
            align-items: flex-start; /* Ù…Ø­Ø§Ø°Ø§Ø© Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø£Ø¹Ù„Ù‰ (Ø§Ù„Ø±Ø£Ø³) */
        }

        .message-row.my-message-row {
            justify-content: flex-end;
            margin-left: 15%; /* Ù…Ø³Ø§Ø­Ø© Ø£ÙƒØ¨Ø± Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø·Ø±Ù Ø§Ù„Ø¢Ø®Ø± */
        }
        
        .message-row.other-message-row {
            justify-content: flex-start;
            margin-right: 15%; /* Ù…Ø³Ø§Ø­Ø© Ø£ÙƒØ¨Ø± Ù„Ø±Ø³Ø§Ø¦Ù„ÙŠ */
        }

        .message-bubble {
            padding: 0.5rem 0.75rem;
            max-width: 100%;
            line-height: 1.35;
            font-size: 0.95em;
            color: var(--text-color);
            /* Ø­ÙˆØ§Ù Ù…Ø³ØªØ¯ÙŠØ±Ø© Ø¬Ø¯Ø§Ù‹ */
            border-radius: 1.2rem; 
            box-shadow: 0 0 1px rgba(0, 0, 0, 0.1); 
        }

        .my-message-row .message-bubble {
            background-color: var(--my-message-bg);
            color: var(--text-color); /* Ø§Ù„Ø£Ø¨ÙŠØ¶ Ø£Ùˆ Ø§Ù„Ø£Ø³ÙˆØ¯ */
            /* Ø¬Ø¹Ù„ Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø³ÙÙ„ÙŠØ© Ø§Ù„ÙŠÙ…ÙŠÙ† Ø£Ù‚Ù„ Ø§Ø³ØªØ¯Ø§Ø±Ø© */
            border-bottom-right-radius: 0.35rem; 
            color: #111111; /* Ù„Ø¬Ø¹Ù„ Ø§Ù„Ù†Øµ Ø£Ø³ÙˆØ¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø®Ø¶Ø± */
        }

        .other-message-row .message-bubble {
            background-color: var(--other-message-bg);
            color: var(--text-color);
            /* Ø¬Ø¹Ù„ Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø³ÙÙ„ÙŠØ© Ø§Ù„ÙŠØ³Ø§Ø± Ø£Ù‚Ù„ Ø§Ø³ØªØ¯Ø§Ø±Ø© */
            border-bottom-left-radius: 0.35rem; 
        }
        
        .message-avatar {
            /* ØªØ¹Ø¯ÙŠÙ„ Ø­Ø¬Ù… Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø±Ù…Ø²ÙŠØ© */
            width: 2rem; 
            height: 2rem;
            border-radius: 50%;
            flex-shrink: 0;
            margin-top: 5px; /* Ù„ØªÙƒÙˆÙ† Ù…Ø­Ø§Ø°ÙŠØ© Ù„Ø£Ø¹Ù„Ù‰ Ø§Ù„ÙÙ‚Ø§Ø¹Ø© */
        }
        
        /* Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø±Ù…Ø²ÙŠØ© Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø±Ø³Ù„ */
        .my-message-row .message-avatar {
            display: none;
        }
        
        .message-username {
            font-size: 0.75em;
            font-weight: 600; /* Ø´Ø¨Ù‡ Ø¹Ø±ÙŠØ¶ */
            color: #999;
            margin-bottom: 2px;
            display: block;
        }

        .my-message-row .message-username {
            color: #000; /* Ù„Ø¬Ø¹Ù„ Ø§Ù„Ø§Ø³Ù… Ø£Ø³ÙˆØ¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø®Ø¶Ø± */
        }

        .message-bubble .time {
            display: block;
            font-size: 0.6em;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.7);
            text-align: right;
            margin-top: 0.25rem;
        }

        .my-message-row .message-bubble .time {
             color: rgba(0, 0, 0, 0.5); /* Ø±Ù…Ø§Ø¯ÙŠ ÙØ§ØªØ­ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø®Ø¶Ø± */
        }
        
        /* Input Area and Send Button */
        .input-container {
            background-color: var(--secondary-bg);
            border-top: 1px solid var(--border-color);
            padding: 0.5rem;
        }
        
        #message-input {
            background-color: var(--tertiary-bg);
            border: none; /* Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø­Ø¯ÙˆØ¯ */
            border-radius: 1.5rem; /* Ù„Ø¬Ø¹Ù„ Ø­Ù‚Ù„ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø¯Ø§Ø¦Ø±ÙŠØ§Ù‹ */
            padding: 0.6rem 1rem;
            color: var(--text-color);
            transition: all 0.2s;
        }
        
        #message-input:focus {
            box-shadow: 0 0 0 2px var(--accent-color); /* ØªØ£Ø«ÙŠØ± ØªØ±ÙƒÙŠØ² iOS */
        }

        #send-button {
            background-color: transparent !important; 
            padding: 0;
            /* Ø²ÙŠØ§Ø¯Ø© Ø­Ø¬Ù… Ø²Ø± Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ù„ÙŠØªÙ†Ø§Ø³Ø¨ Ù…Ø¹ Ø§Ù„ØµÙˆØ±Ø© */
            width: 2.2rem; 
            height: 2.2rem;
        }
        
        #send-button img {
            width: 100%; 
            height: 100%;
            object-fit: cover; 
            border-radius: 50%; 
        }

        #send-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        /* Active Count Style (similar to iOS system text) */
        #active-count {
            color: var(--accent-color);
            font-weight: 700;
        }
        
        .limit-info {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.75rem;
            margin-top: 0.5rem;
        }

        .limit-info #message-counter {
            color: var(--info-color);
        }
    </style>
    
</head>
<body class="antialiased">

    <audio id="send-sound" src="send.mp3" preload="auto"></audio>
    <audio id="backSound" src="back.mp3" preload="metadata"></audio>

    <div class="chat-container">

        <header class="chat-header w-full p-4 flex justify-between items-center sticky top-0 z-10"> 
            
            <a id="backButton" href="main.html" class="flex items-center text-white hover:opacity-80 transition duration-150 font-semibold p-1 -ml-1">
                <svg class="w-6 h-6 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M15 19l-7-7 7-7"></path></svg>
                <span class="text-sm" style="color: #FFFFFF;">Back</span> 
            </a>
            
            <div class="flex items-center text-sm">
                <svg class="w-4 h-4 mr-1 fill-current" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="color: var(--accent-color);"><path d="M16 7C16 9.20914 14.2091 11 12 11C9.79086 11 8 9.20914 8 7C8 4.79086 9.79086 3 12 3C14.2091 3 16 4.79086 16 7Z" stroke="currentColor" stroke-width="2"/><path d="M12 14C8.13401 14 5 17.134 5 21H19C19 17.134 15.866 14 12 14Z" stroke="currentColor" stroke-width="2"/></svg>
                <span id="active-count" class="font-bold">0</span>
                <span class="ml-1 text-neutral-400">Active Now</span>
            </div>
        </header>

        <div id="messages-window" class="messages-window flex flex-col space-y-2">
            </div>

        <div class="input-container">
            <div class="flex items-center">
                
                <input type="text" id="message-input" placeholder="iMessage..." maxlength="200"
                       class="flex-grow outline-none">
                
                <button id="send-button" disabled
                        class="ml-2 rounded-full flex items-center justify-center transition duration-200">
                    <img src="send.png" alt="Send" class="w-full h-full object-cover rounded-full ios-shadow">
                </button>
            </div>
            
            <div class="limit-info text-center">
                <span id="message-counter" class="font-bold">2</span> messages remaining every 10 minutes.
            </div>
        </div>
    </div>

    <script>
        // JavaScript Logic
        document.addEventListener('DOMContentLoaded', () => {
            const activeCountElement = document.getElementById('active-count');
            const messageInput = document.getElementById('message-input');
            const sendButton = document.getElementById('send-button');
            const messagesWindow = document.getElementById('messages-window');
            const sendSound = document.getElementById('send-sound'); 
            const backButton = document.getElementById('backButton');
            const backSound = document.getElementById('backSound');

            // --- AUDIO UTILITY (Unchanged) ---
            function playSound(audioElement) {
                if (audioElement) {
                    audioElement.currentTime = 0;
                    audioElement.play().catch(e => console.log('Audio play blocked:', e));
                }
            }

            // --- PERSISTENCE SETUP (Unchanged) ---
            const STORAGE_KEY = 'chat_message_history_usdt';
            const RATE_LIMIT_COUNT_KEY = 'rate_limit_count';
            const RATE_LIMIT_START_TIME_KEY = 'rate_limit_start_time';
            let messageHistory = [];
            
            // --- MESSAGE LIMIT CONSTANTS (Unchanged) ---
            let messageCount = 0; 
            let rateLimitStartTime = null; 
            const MAX_MESSAGES = 2; 
            const RESET_TIME_MS = 10 * 60 * 1000; 

            // Utility functions (Unchanged)
            const random = (arr) => arr[Math.floor(Math.random() * arr.length)];
            const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
            const getTimeString = (timestamp = null) => {
                const date = timestamp ? new Date(timestamp) : new Date();
                return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });
            };
            
            function generateRandom10DigitString() {
                return String(Math.floor(1000000000 + Math.random() * 9000000000));
            }

            // --- AVATAR GENERATION FUNCTION (Unchanged) ---
            // Function to generate a stable random number based on a seed
            function mulberry32(seed) {
                return function() {
                    seed = seed + 0x6D2B79F5 | 0;
                    let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
                    t = t + Math.imul(t ^ t >>> 7, 61 | t);
                    return ((t ^ t >>> 14) >>> 0) / 4294967296;
                }
            }
            
            let avatarSeeds = {}; // Store seeds for consistent avatars

            function generateRealisticAvatarUrl(userId) {
                if (!avatarSeeds[userId]) {
                    // Generate a new seed if it doesn't exist for this userId
                    avatarSeeds[userId] = Math.floor(Math.random() * 1000000); 
                }
                const seed = avatarSeeds[userId];
                const rand = mulberry32(seed); // Create a seeded random number generator
                
                const gender = rand() < 0.5 ? 'men' : 'women';
                const imageNum = Math.floor(rand() * 99); // Random number from 0-98 for RandomUser.me
                return `https://randomuser.me/api/portraits/thumb/${gender}/${imageNum}.jpg`;
            }

            // --- USER DATA SETUP (Unchanged) ---
            let myId = localStorage.getItem('chat_user_id');
            if (!myId || !myId.startsWith('Client_')) {
                myId = "Client_" + Math.floor(10000 + Math.random() * 90000); 
                localStorage.setItem('chat_user_id', myId);
            }
            
            // ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø±Ù…Ø²ÙŠØ© Ø§Ù„Ø®Ø§ØµØ© Ø¨ÙŠ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù€ ID
            const MY_ID = myId; 
            const MY_AVATAR = generateRealisticAvatarUrl(MY_ID);

            // --- VIRTUAL USER AND DIALOGUE DATA (Unchanged) ---
            const VIRTUAL_USERS = [
                { id: "user_4837", name: "Alice" },
                { id: "client_9102", name: "Bob" },
                { id: "member_3321", name: "Charlie" },
                { id: "guest_0045", name: "Dana" },
                { id: "alpha_7618", name: "Eve" },
                { id: "beta_5229", name: "Frank" },
                { id: "gamma_3110", name: "Grace" },
            ];
            
            // --- STATEMENTS (Unchanged) ---
            
            const SHORT_STATEMENTS = [
                "Hi", "Hello", "ok", "Good morning", "Morning!", "ğŸ‘", "I see.", 
                "thanks", "got it", "yup", "alright", "yeah", "Nice", "cool", "I agree"
            ];

            const LONG_STATEMENTS = [
                "I finally got my withdrawal. Super fast! Less than %s%.",
                "Is anyone else using the new %s% feature?",
                "It's great that this bot is %s% legit and not another scam.",
                "Just confirmed a successful deposit. Took exactly %s% minutes.",
                "The current flash duration is unbelievably low, around %s%.",
                "I was skeptical about the %s%, but it truly works.",
                "This is the most reliable %s% bot I've found.",
            ];

            const FLOW_PARTS = {
                TERMS: [
                    "anti-scam protocol", "withdrawal speed", "deposit processing time",
                    "liquidity pool connection", "flash completion rate", "TRC20 fee structure",
                ],
                VALUES: [
                    "3 seconds", "5 minutes", "99%", "0.5 seconds", "2 hours",
                ],
            };
            
            // Keyword-based replies (Unchanged)
            const REPLY_MAP = {
                "withdraw": [
                    "Withdrawals are instant now. They take around %s% once processed.",
                    "It's absolutely reliable. I cashout %s% daily.",
                    "I checked the wallet transactions; totally legit withdrawal proof.",
                ],
                "cashout": [
                     "Withdrawals are instant now. They take around %s% once processed.",
                    "It's absolutely reliable. I cashout %s% daily.",
                ],
                "money": [
                     "Withdrawals are instant now. They take around %s% once processed.",
                    "It's absolutely reliable. I cashout %s% daily.",
                ],
                "legit": [
                    "The bot is 100% legit. No KYC required and the process is transparent.",
                    "It's verified. You can check the transaction history.",
                    "It's not a scam; this is the real deal with instant %s%!",
                ],
                "scam": [
                    "It's not a scam; this is the real deal with instant %s%!",
                    "They implemented a strong %s% to prevent any fraud.",
                    "Absolutely safe. I've been using it for weeks without issues.",
                ],
                "safe": [
                    "Absolutely safe. I've been using it for weeks without issues.",
                    "The security measures on the %s% are really high.",
                ],
                "deposit": [
                    "The deposit window is %s% short. Funds are active almost immediately.",
                    "Funding takes %s% to reflect, depending on network congestion.",
                    "I recommend starting with a small %s% test deposit.",
                ],
                "fast": [
                    "It's incredibly fast! The whole process, including %s%, takes less than 3 minutes.",
                    "The speed is key. You won't find a faster %s% bot.",
                ],
                "quick": [
                    "It's incredibly fast! The whole process, including %s%, takes less than 3 minutes.",
                    "The speed is key. You won't find a faster %s% bot.",
                ],
                "default": [
                    "I think that's covered in the %s% FAQ.",
                    "Are you asking about the %s% or the duration?",
                    "Generally, the bot is highly reliable in all %s% aspects.",
                ]
            };

            // --- RATE LIMIT & PERSISTENCE (Unchanged) ---
            
            function loadRateLimit() {
                const savedCount = localStorage.getItem(RATE_LIMIT_COUNT_KEY);
                const savedStartTime = localStorage.getItem(RATE_LIMIT_START_TIME_KEY);
                if (savedCount !== null) messageCount = parseInt(savedCount, 10);
                if (savedStartTime !== null) rateLimitStartTime = parseInt(savedStartTime, 10);
                resetMessageLimit(false); 
            }

            function saveRateLimit() {
                localStorage.setItem(RATE_LIMIT_COUNT_KEY, messageCount.toString());
                if (rateLimitStartTime) localStorage.setItem(RATE_LIMIT_START_TIME_KEY, rateLimitStartTime.toString());
                else localStorage.removeItem(RATE_LIMIT_START_TIME_KEY);
            }

            function resetMessageLimit(forceCheck = true) {
                if (rateLimitStartTime) {
                    const timeElapsed = Date.now() - rateLimitStartTime;
                    if (timeElapsed >= RESET_TIME_MS) {
                        messageCount = 0;
                        rateLimitStartTime = null;
                        saveRateLimit(); 
                    }
                }
                if (forceCheck) checkMessageLimit();
            }
            
            function checkMessageLimit() {
                resetMessageLimit(false); 
                const remaining = MAX_MESSAGES - messageCount;
                const infoText = document.querySelector('.limit-info');
                
                if (remaining <= 0 && rateLimitStartTime) {
                    const timeElapsed = Date.now() - rateLimitStartTime;
                    const timeRemainingMs = RESET_TIME_MS - timeElapsed;
                    const minutes = Math.ceil(timeRemainingMs / 60000); 
                    infoText.innerHTML = `Max limit reached. Reset in <span class="font-bold" style="color: var(--info-color);">${minutes} minutes</span>.`;
                } else {
                    infoText.innerHTML = `<span id="message-counter" class="font-bold" style="color: var(--info-color);">${remaining}</span> messages remaining every 10 minutes.`;
                }
                sendButton.disabled = remaining <= 0 || messageInput.value.trim() === "";
            }

            function saveMessages() {
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(messageHistory));
                } catch (e) {
                    console.error("Error saving message history to localStorage", e);
                }
            }

            function loadMessages() {
                const savedData = localStorage.getItem(STORAGE_KEY);
                if (savedData) {
                    try {
                        messageHistory = JSON.parse(savedData);
                        messageHistory.forEach(msg => {
                            renderMessage(msg, true);
                        });
                        messagesWindow.scrollTop = messagesWindow.scrollHeight;
                    } catch (e) {
                        console.error("Error parsing saved message history", e);
                        messageHistory = []; 
                    }
                }
            }

            // --- CORE RENDERING FUNCTION (Unchanged) ---
            function renderMessage(messageData, isHistoryLoad = false) {
                const { username, messageText, avatarHash, isMine, timestamp } = messageData; 
                
                const timeString = getTimeString(timestamp);
                // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù€ avatarHash (Ø§Ù„Ø°ÙŠ Ù‡Ùˆ Ø§Ù„Ù€ ID) Ù„ØªÙˆÙ„ÙŠØ¯ ØµÙˆØ±Ø© ÙˆØ§Ù‚Ø¹ÙŠØ©
                const avatarUrl = isMine ? MY_AVATAR : generateRealisticAvatarUrl(avatarHash);
                
                const messageRow = document.createElement('div');
                messageRow.classList.add('message-row', isMine ? 'my-message-row' : 'other-message-row');

                messageRow.innerHTML = `
                    <img src="${avatarUrl}" alt="${username} Avatar" class="message-avatar ${isMine ? 'hidden' : ''}">
                    <div class="message-bubble ios-shadow">
                        <span class="message-username ${isMine ? 'text-black/70' : 'text-neutral-400'}">${username}</span>
                        <span>${messageText}</span>
                        <span class="time">${timeString}</span>
                    </div>
                `;
                messagesWindow.appendChild(messageRow);
                messagesWindow.scrollTop = messagesWindow.scrollHeight;

                if (!isHistoryLoad) {
                    messageHistory.push(messageData);
                    saveMessages();
                }
            }


            // --- MESSAGE GENERATION FUNCTIONS (Unchanged) ---
            
            let lastUserIndex = -1;
            function generateFlowMessage() {
                let userIndex;
                do {
                    userIndex = randomInt(0, VIRTUAL_USERS.length - 1);
                } while (userIndex === lastUserIndex);
                lastUserIndex = userIndex;
                
                const user = VIRTUAL_USERS[userIndex];
                const randomUserId = user.name; // Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ù‡Ù†Ø§
                
                // --- Ù…Ù†Ø·Ù‚ ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„ØªÙƒØ±Ø§Ø±: 80% Ø±Ø³Ø§Ø¦Ù„ Ø·ÙˆÙŠÙ„Ø©ØŒ 20% Ø±Ø³Ø§Ø¦Ù„ Ù‚ØµÙŠØ±Ø© ---
                const useShortMessage = Math.random() < 0.20; 
                let messageText;

                if (useShortMessage) {
                    messageText = random(SHORT_STATEMENTS);
                } else {
                    messageText = random(LONG_STATEMENTS);
                    
                    // ÙŠØªÙ… Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ù…Ø¦ÙˆÙŠØ© ÙÙŠ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø·ÙˆÙŠÙ„Ø© ÙÙ‚Ø·
                    messageText = messageText.replace(/%s%/, random(FLOW_PARTS.TERMS));
                    messageText = messageText.replace(/%s%/, random(FLOW_PARTS.VALUES));
                }
                
                const messageData = {
                    username: randomUserId, 
                    messageText: messageText,
                    avatarHash: user.id, // Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù€ ID ÙƒÙ€ Hash Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØ±Ø©
                    isMine: false,
                    timestamp: Date.now()
                };
                
                renderMessage(messageData);
            }

            function generateCustomReply(userMessage) {
                const normalizedMessage = userMessage.toLowerCase();
                let replyKey = 'default';

                for (const key in REPLY_MAP) {
                    if (normalizedMessage.includes(key)) {
                        replyKey = key;
                        break;
                    }
                }

                let userIndex;
                do {
                    userIndex = randomInt(0, VIRTUAL_USERS.length - 1);
                } while (userIndex === lastUserIndex);
                
                const user = VIRTUAL_USERS[userIndex];
                const randomUserId = user.name;

                let replyText = random(REPLY_MAP[replyKey]);
                replyText = replyText.replace(/%s%/, random(FLOW_PARTS.TERMS));
                replyText = replyText.replace(/%s%/, random(FLOW_PARTS.VALUES));

                const messageData = {
                    username: randomUserId, 
                    messageText: replyText,
                    avatarHash: user.id, 
                    isMine: false,
                    timestamp: Date.now() 
                };

                const FIXED_REPLY_DELAY = 7000; 
                setTimeout(() => {
                    renderMessage(messageData);
                }, FIXED_REPLY_DELAY);
            }

            // --- MESSAGE INJECTION LOOP (Unchanged) ---
            const MESSAGE_RATE_MS = 6000; 
            let flowInterval = null; 

            function startFlow() {
                if (!flowInterval) {
                    flowInterval = setInterval(generateFlowMessage, MESSAGE_RATE_MS);
                }
            }
            
            // --- Send Message Functionality (Unchanged) ---

            function sendMessage() {
                const messageText = messageInput.value.trim();

                resetMessageLimit(false); 

                if (messageText && messageCount < MAX_MESSAGES) {
                    
                    playSound(sendSound); 
                    
                    const messageData = {
                        username: MY_ID, 
                        messageText: messageText,
                        avatarHash: MY_ID, // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù€ ID Ù…Ø¨Ø§Ø´Ø±Ø© ÙƒÙ€ Hash Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ØµÙˆØ±Ø©
                        isMine: true,
                        timestamp: Date.now()
                    };
                    renderMessage(messageData);
                    
                    generateCustomReply(messageText);

                    messageCount++;
                    if (messageCount === 1) { 
                        rateLimitStartTime = Date.now();
                    }
                    saveRateLimit(); 
                    
                    checkMessageLimit();
                    messageInput.value = '';
                    
                } else if (messageCount >= MAX_MESSAGES) {
                    alert('You have reached the maximum message limit (2) per 10 minutes.');
                }
            }

            sendButton.addEventListener('click', sendMessage);
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    sendMessage();
                }
            });

            // --- Header & Footer Interaction (Unchanged) ---
            backButton.addEventListener('click', function(e) {
                e.preventDefault(); 
                playSound(backSound); 
                setTimeout(() => {
                    window.location.href = backButton.getAttribute('href'); 
                }, 150); 
            });


            // --- Active Users Count & Initialization (Unchanged) ---
            const MIN_USERS = 890;
            const MAX_USERS = 3000;
            const MAX_CHANGE = 5; 

            function updateActiveCount() {
                let currentCount = parseInt(activeCountElement.textContent) || MIN_USERS;
                const change = Math.floor(Math.random() * (MAX_CHANGE * 2 + 1)) - MAX_CHANGE; 
                let newCount = currentCount + change;

                if (newCount < MIN_USERS) newCount = MIN_USERS;
                if (newCount > MAX_USERS) newCount = MAX_USERS;

                activeCountElement.textContent = newCount;
                const randomDelay = Math.floor(Math.random() * 5000) + 5000; 
                setTimeout(updateActiveCount, randomDelay);
            }

            // --- INIT ---
            loadMessages(); 
            loadRateLimit(); 
            updateActiveCount();
            setInterval(checkMessageLimit, 1000); 
            messageInput.addEventListener('input', checkMessageLimit);
            checkMessageLimit();
            startFlow();
        });
    </script>

</body>
</html>
